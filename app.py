# -*- coding: utf-8 -*-
"""App.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11IUc7cm1RQGevo2JLWRCKVxKrI0omXA3
"""

# import time
# # Tiempo al inicio con alta resolución
# start_time = time.perf_counter()


import numpy as np
import pandas as pd
from hdbscan import HDBSCAN
from sklearn.preprocessing import StandardScaler
import warnings

warnings.filterwarnings("ignore", category=RuntimeWarning)

def load_and_clean_data(filepath):
    df = pd.read_excel(filepath)
    negative_conditions = (df['Active_energy'] < 0) | (df['Reactive_energy'] < 0) | (df['Voltaje_FA'] < 0) | (df['Voltaje_FC'] < 0)
    df = df[~negative_conditions].reset_index(drop=True)
    df.drop(['Source.Name', 'CLIENTE '], axis=1, inplace=True)
    new_names = {'Active_energy': 'Energía_Activa', 'Reactive_energy': 'Energía_Reactiva', 'Proper': 'Cliente', 'Sector Económico:': 'Sector Económico'}
    df.rename(columns=new_names, inplace=True)
    return df

def add_energy_metrics(df):
    df['Potencia_Aparente'] = df['Energía_Activa'] + df['Energía_Reactiva']
    df['eficiencia_energetica'] = np.where(df['Potencia_Aparente'] != 0, (df['Energía_Activa'] / df['Potencia_Aparente']) * 100, np.nan)
    df['energia_total_consumida'] = df['Energía_Activa'] + df['Energía_Reactiva']
    df['Energía_Aparente'] = np.sqrt(df['Energía_Activa']**2 + df['Energía_Reactiva']**2)
    df['Factor_de_Potencia'] = df['Energía_Activa'] / df['Energía_Aparente']
    df['Desviación_Voltaje'] = abs(df['Voltaje_FA'] - df['Voltaje_FC'])
    return df

def fill_na_with_median(df):
    for column in df.columns:
        if df[column].dtype in [np.float64, np.float32]:
            median_value = df[column].median()
            df[column].fillna(median_value, inplace=True)
    return df

def analyze_clusters(df):
    df = fill_na_with_median(df)
    scaler = StandardScaler()
    columnas_para_escalar = ['Energía_Activa', 'Energía_Reactiva', 'Voltaje_FA', 'Voltaje_FC',
                             'eficiencia_energetica', 'energia_total_consumida', 'Energía_Aparente',
                             'Factor_de_Potencia', 'Desviación_Voltaje']
    df_analisis_scaled = scaler.fit_transform(df[columnas_para_escalar])
    hdbscan_model = HDBSCAN(min_cluster_size=5, min_samples=88, gen_min_span_tree=True, prediction_data=True)
    clusters = hdbscan_model.fit_predict(df_analisis_scaled)
    df['Cluster'] = clusters
    df['Es_Anomalia'] = (clusters == -1).astype(int)
    outlier_scores = hdbscan_model.outlier_scores_
    df['Outlier_Score'] = outlier_scores
    threshold = np.percentile(outlier_scores[df['Cluster'] == -1], 95)
    df['Es_Anomalia'] = np.where(df['Outlier_Score'] >= threshold, 2, df['Es_Anomalia'])
    return df[['Fecha', 'Cliente', 'Cluster', 'Es_Anomalia', 'Outlier_Score']].copy()

def analyze_iqr(df):
    columnas_numericas = ['Energía_Activa', 'Energía_Reactiva', 'Voltaje_FA', 'Voltaje_FC',
                          'eficiencia_energetica', 'energia_total_consumida', 'Energía_Aparente',
                          'Factor_de_Potencia', 'Desviación_Voltaje']
    for col in columnas_numericas:
        Q1 = df[col].quantile(0.25)
        Q3 = df[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        lower_critical = Q1 - 8.0 * IQR
        upper_critical = Q3 + 8.0 * IQR
        df[col + '_anomalía'] = ((df[col] < lower_bound) | (df[col] > upper_bound)).astype(int)
        df[col + '_crítica'] = ((df[col] < lower_critical) | (df[col] > upper_critical)).astype(int)
    df['Total_anomalías_IQR'] = df[[col + '_anomalía' for col in columnas_numericas]].sum(axis=1)
    df['Total_anomalías_críticas_IQR'] = df[[col + '_crítica' for col in columnas_numericas]].sum(axis=1)
    df['Es_Anomalia_IQR'] = np.where(df['Total_anomalías_críticas_IQR'] > 0, 2,
                                     np.where(df['Total_anomalías_IQR'] > 0, 1, 0))
    return df[['Cliente', 'Fecha'] + [col + suffix for col in columnas_numericas for suffix in ['_anomalía', '_crítica']] +
           ['Total_anomalías_IQR', 'Total_anomalías_críticas_IQR', 'Es_Anomalia_IQR']]

def main():
    filepath = "Clientes consolidada.xlsx"
    df = load_and_clean_data(filepath)
    df = add_energy_metrics(df)
    df_metrics = fill_na_with_median(df)
    df_metrics.to_csv('energy_metrics.csv', index=False)
    df_hdbscan_final = analyze_clusters(df_metrics)
    df_hdbscan_final.to_csv('hdbscan_final.csv', index=False)
    df_iqr_final = analyze_iqr(df_metrics)
    df_iqr_final.to_csv('iqr_final.csv', index=False)

if __name__ == "__main__":
    main()




# # Tiempo al final
# end_time = time.perf_counter()
# # Calcular la duración
# duration = end_time - start_time
# print(f"El código se ejecutó en {duration} segundos.")

